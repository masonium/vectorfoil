use crate::common::*;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum EdgeType {
    Visible,
    Invisible,
    Hidden, // behind another triangle
    Split, // generated by an internal split
    Culled,
}

#[derive(Debug, Clone, PartialEq)]
pub struct Tri {
    pub p: [DVec4; 3],
    pub e: [EdgeType; 3],
}

impl Tri {
    /// Hide all edges of the triangle, consuming itself.
    pub fn hide(&mut self)  {
	self.e[0] = EdgeType::Hidden;
	self.e[1] = EdgeType::Hidden;
	self.e[2] = EdgeType::Hidden;
    }

    pub fn is_hidden(&self) -> bool {
	self.e.iter().all(|x| *x == EdgeType::Hidden)
    }
}

/// Internally, all primitive coordinates are kept in 4D as (x/w, y/w,
/// z/w, w).
#[derive(Clone, Debug, PartialEq)]
pub enum Primitive {
    /// Triangle
    Triangle { tri: Tri },

    /// Line segment
    Line { points: [DVec4; 2] },

    /// Single point
    Point { point: DVec4 },
}

impl Primitive {
    pub fn centroid(&self) -> DVec3 {
	match self {
	    Self::Point { point } => point.xyz(),
	    Self::Line { points } => (points[0] + points[1]).xyz() * 0.5,
	    Self::Triangle { tri: Tri { p, .. } } => { p[0] + p[1] + p[2] }.xyz() / 3.0,
	}
    }
}

/// Wrapper for `Primitive` on the heap, to be sorted by z-value for
/// rendering.
#[derive(Debug, Clone, PartialEq)]
pub struct ZsortPrim {
    pub p: Primitive,
    z: f64,
}

impl From<Primitive> for ZsortPrim {
    fn from(p: Primitive) -> Self {
	let z = -p.centroid().z;
	ZsortPrim { p, z }
    }
}

impl Eq for ZsortPrim {}

impl std::cmp::PartialOrd for ZsortPrim {
    fn partial_cmp(&self, rhs: &Self) -> Option<std::cmp::Ordering> {
	self.z.partial_cmp(&rhs.z)
    }
}

impl std::cmp::Ord for ZsortPrim {
    fn cmp(&self, rhs: &Self) -> std::cmp::Ordering {
	self.partial_cmp(rhs).unwrap()
    }
}
